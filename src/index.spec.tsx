import {renderHook, cleanup, act} from 'react-hooks-testing-library'

import useAsyncCall from '.'

/**
 * Hiding output of console.error due to excessive errors generated by
 * recat-testing-library about the requirement for `act` around
 * actions which update the state
 */
const consoleError = console.error.bind(console)
beforeAll(() => {
  console.error = () => {}
})
afterAll(() => {
  console.error = consoleError
})

afterEach(cleanup)

describe('use-async-call', () => {
  it('sets the response value to the result of the promise', async () => {
    const call = jest.fn(() => Promise.resolve(true))
    const {result, waitForNextUpdate} = renderHook(() => useAsyncCall(call))

    expect(result.current[0].data).toBe(null)
    expect(call).toHaveBeenCalled()

    await waitForNextUpdate()

    expect(result.current[0].data).toBe(true)
  })

  it('calls success callback after success with data', async () => {
    const call = jest.fn(() => Promise.resolve(true))
    const onSuccess = jest.fn()
    const {waitForNextUpdate} = renderHook(() =>
      useAsyncCall(call, {onSuccess})
    )

    expect(onSuccess).not.toHaveBeenCalled()

    await waitForNextUpdate()

    expect(onSuccess).toHaveBeenCalledWith(true)
  })

  it('sets the error in response after rejection', async () => {
    const err = new Error()
    const call = jest.fn(() => Promise.reject(err))
    const {result, waitForNextUpdate} = renderHook(() => useAsyncCall(call))

    expect(result.current[0].data).toBe(null)
    expect(result.current[0].error).toBe(null)
    expect(call).toHaveBeenCalled()

    await waitForNextUpdate()

    expect(result.current[0].data).toBe(null)
    expect(result.current[0].error).toBe(err)
  })

  it('calls error callback after error with error', async () => {
    const err = new Error()
    const call = jest.fn(() => Promise.reject(err))
    const onSuccess = jest.fn()
    const onFailure = jest.fn()
    const {waitForNextUpdate} = renderHook(() =>
      useAsyncCall(call, {onSuccess, onFailure})
    )

    expect(onSuccess).not.toHaveBeenCalled()
    expect(onFailure).not.toHaveBeenCalled()

    await waitForNextUpdate()

    expect(onSuccess).not.toHaveBeenCalled()
    expect(onFailure).toHaveBeenCalledWith(err)
  })

  it('does not call handlers when the input method changes', async () => {
    const call = jest.fn(() => Promise.resolve(true))
    const onSuccess = jest.fn()
    const {waitForNextUpdate, rerender} = renderHook(
      ({caller}) => useAsyncCall(caller, {onSuccess}),
      {initialProps: {caller: call}}
    )

    expect(onSuccess).not.toHaveBeenCalled()

    const nextCall = jest.fn(() => Promise.resolve(false))
    rerender({caller: nextCall})

    expect(onSuccess).not.toHaveBeenCalled()

    await waitForNextUpdate()

    expect(onSuccess).toHaveBeenCalledTimes(1)
    expect(onSuccess).toHaveBeenCalledWith(false)
  })

  it('calls to update function, update the loading state and data state', async () => {
    const call = jest.fn(() => Promise.resolve(true))
    const {result, waitForNextUpdate} = renderHook(() => useAsyncCall(call))

    expect(result.current[0].data).toBe(null)
    expect(call).toHaveBeenCalled()

    await waitForNextUpdate()

    expect(result.current[0].data).toBe(true)

    const update = jest.fn(() => Promise.resolve(false))
    const onSuccess = jest.fn()

    act(() => {
      result.current[1](update, {onSuccess})
    })

    expect(update).toHaveBeenCalledTimes(1)
    expect(result.current[0].loading).toBe(true)
    expect(onSuccess).not.toBeCalled()

    await waitForNextUpdate()

    expect(result.current[0].loading).toBe(false)
    expect(result.current[0].data).toBe(false)
    expect(onSuccess).toHaveBeenCalledWith(false)
  })
})
